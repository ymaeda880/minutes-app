# -*- coding: utf-8 -*-
# lib/explanation.py
#
# 音声分割ツール（MP3/WAV）のロジックと使い方を説明する expander（Streamlit用）

from __future__ import annotations
import streamlit as st

# 音声ファイル分解

def render_audio_split_expander() -> None:
    """
    音声分割ツール（MP3/WAV・オーバーラップ付き）のロジックと使い方を expander で描画します。
    pages/xx_音声分割.py などから呼び出して使います。
    """
    with st.expander("ℹ️ 音声分割ツールのしくみと使い方（クリックで展開）", expanded=False):
        st.markdown(
            """
            ## 1. このツールが行う処理（全体の流れ）

            1. アップロードした **MP3 / WAV** を `pydub.AudioSegment` として読み込みます。  
            2. 指定した **チャンク長（分）** で音声を分割します。  
            3. 隣接チャンクには、指定した **オーバーラップ（重なり）** を付けます。  
            4. 各チャンクには開始時刻・終了時刻・持続時間を付与します。  
            5. 指定フォーマット（MP3 / WAV）でファイルを書き出し、ZIP にまとめます。  
            6. 分割一覧（プレビュー表）と ZIP ダウンロードボタンを表示します。

            ---

            ## 2. パラメータの意味

            ### 🔹 チャンク長（分）
            - 1チャンクあたりの再生時間です。
            - 例：15分 → 0–15分, 14分–29分, 28分–43分 … のように切り分けます。

            ### 🔹 オーバーラップ（分）
            - 隣り合うチャンクの重複部分。
            - 文字起こしや話者分離で文脈を保つために有効。
            - 例：チャンク長15分・オーバーラップ1分  
              → `chunk2.start = chunk1.end - 1min`

            > ⚠ **オーバーラップはチャンク長より短い必要があります。**

            ### 🔹 書き出しフォーマット（mp3 / wav）
            - WAV：PCM16 で出力  
            - MP3：選択したビットレートで出力（または「自動」）

            ### 🔹 ビットレート（MP3のみ）
            - MP3 の品質設定。（128k〜320k）

            ### 🔹 フェード（ms）
            - クリックノイズ低減のため、各チャンクの頭と末尾に
              フェードイン／フェードアウトを適用できます。

            ### 🔹 最後の“短すぎる尻尾”の吸収
            - 最後の端数部分が **オーバーラップより小さい場合**  
              → 無理に独立チャンクにせず **前のチャンクに吸収** します。
            - 不要な細切れファイルを防ぐオプションです。

            ---

            ## 3. 出力されるファイル

            ZIP の中には：

            - `audio_part000_000000-001500.mp3` などのチャンク音声
            - 全チャンクのインデックス CSV  
              （開始ms / 終了ms / hh:mm:ss 付き）

            ---

            ## 4. 注意事項（保存時の警告について）

            LAN 内や自己署名 HTTPS 環境では、  
            **Chrome が ZIP ダウンロードを「安全でない」と警告する** 場合があります。

            - その場合は右上に出る警告 → **「保存」** をクリックしてください。
            - 内容はすべてローカル作成のファイルで安全です。

            ---

            ## 5. よくある質問（FAQ）

            ### Q1. 文字起こし用に最適な設定は？
            - **チャンク長：10〜20分**
            - **オーバーラップ：30秒〜1分**
            - Whisper / Deepgram 等との相性が良いです。

            ### Q2. MP3 と WAV のどちらが良い？
            - **WAV（PCM16）：** 高品質。文字起こし精度が上がりやすい  
            - **MP3：** 軽量で共有しやすい

            ### Q3. オーバーラップを付ける理由は？
            - 文脈が途切れにくくなるため  
            - AI 文字起こしが途中で発話を切り捨てる問題の対策

            ---

            以上が音声分割ツールの全体ロジックと使い方です。
            """
        )

# 文字起こし

def render_transcribe_continuous_expander() -> None:
    """
    「① 文字起こし（連続対応）」ページのロジックと使い方を expander で描画します。
    pages/05_文字起こし（連続対応）.py などから呼び出して使います。
    """
    with st.expander("ℹ️ ① 文字起こし（連続対応）のしくみと使い方（クリックで展開）", expanded=False):
        st.markdown(
            """
            ## 1. このページの役割

            - OpenAI の **Transcribe / Whisper API** を使って、音声ファイルを文字起こしするページです。
            - **複数の音声ファイル** をアップロードすると、
              1ファイルずつ順番に文字起こしし、最後に **1つのテキストとして連結** します。
            - 連結テキストは、次のタブ「② 話者分離（Markdown）」へそのまま引き継げます。

            ---

            ## 2. 全体の処理の流れ

            1. API キーや価格テーブルなどの共通設定を読み込みます。
            2. サイドバーで **モデル・言語・response_format・プロンプト** 等を指定します。
            3. 複数の音声ファイルをアップロードします（順番通りに処理）。
            4. 各ファイルについて Transcribe / Whisper API を呼び出します（リトライ付き）。
            5. ファイルごとに
               - テキスト表示
               - 個別ダウンロード（.txt）
               - 推定コストと処理時間（メトリクス表）
               を表示します。
            6. 最後に、全てのテキストを **つなぎ目マーカー入り** で連結して表示・ダウンロード可能にします。
            7. 連結テキストを `st.session_state["transcribed_text"]` に保存し、
               話者分離タブへ引き継ぐためのボタンを表示します。

            ---

            ## 3. 主なパラメータの説明

            ### 🔹 モデル選択（whisper-1 / gpt-4o-mini-transcribe / gpt-4o-transcribe）
            - **whisper-1**  
              - 既存の Whisper API。互換性重視。
            - **gpt-4o-mini-transcribe**  
              - 低コスト・高速。日常的な会議やメモ用途に向く。
            - **gpt-4o-transcribe**  
              - 精度重視。重要な議事録や長時間のインタビューなどに向く。

            モデルごとの **1分あたりの価格** は
            `TRANSCRIBE_PRICES_USD_PER_MIN` / `WHISPER_PRICE_PER_MIN` から取得して、
            後述のコスト計算に利用します。

            ### 🔹 アップロードファイル
            - 複数ファイルを選択可能（.wav / .mp3 / .m4a / .webm / .ogg）。
            - アップローダに表示された順番のまま上から処理します。
            - 各ファイルの長さは `lib.audio.get_audio_duration_seconds()` で推定します。

            ### 🔹 response_format
            - `"json"`, `"text"`, `"srt"`, `"vtt"` から選択。
            - `json` の場合は `resp.json()["text"]` を取り出し、
              それ以外の場合は `resp.text` をテキストとして扱います。

            ### 🔹 言語コード（language）
            - 例：`ja`, `en` など。  
            - 空欄にすると **自動判定** に任せます。

            ### 🔹 Transcribe プロンプト
            - 誤変換しやすい固有名詞や、
              「【】などのラベルを入れない」等の **抑止指示** を短く書く欄です。
            - 空欄の場合は `prompt` を API に送らず、モデルにお任せします。

            ### 🔹 【…】除去オプション
            - `書き起こし後に【…】を除去する` にチェックを入れると、
              `strip_bracket_tags()` で全角の【…】に囲まれた短いタグを削除します。
            - 例：`【笑】`, `【ノイズ】` のようなラベルを後処理で消したい場合に使います。

            ### 🔹 通貨換算（USD/JPY）
            - `TRANSCRIBE_PRICES_USD_PER_MIN` と音声の分数から **概算USD** を計算し、
              さらに `USD/JPY` レートを掛けて **概算JPY** を出します。
            - レートは `st.session_state["usd_jpy"]` に保存され、次回以降も保持されます。

            ---

            ## 4. 出力内容

            ### 4-1. ファイル別の表示

            各ファイルごとに、右側ペインに以下を表示します。

            - テキストエリア（個別の文字起こし結果）
            - `.txt` ダウンロードボタン（UTF-8）
            - メトリクス表
              - 処理時間（秒）
              - 音声長（秒 / 分）
              - 概算料金（USD / JPY）
              - request-id（トラブルシュート用）
              - 使用モデル

            ### 4-2. 連結テキスト

            全てのファイルを処理した後に：

            - 「🔗 連結テキスト（全ファイル）」として一括表示。
            - `.txt` で一括ダウンロード可能。
            - 「📋 連結テキストをコピー」ボタンで
              クリップボードへコピーするための小さな JavaScript ボタンを表示。
            - 各ファイルの境界には  
              `----- ここがつなぎ目です（◯◯ と次のファイルの間）-----`  
              というマーカーを自動挿入します。

            ### 4-3. 集計メトリクス

            - 全ファイルの
              - 合計処理時間
              - 合計音声長
              - 合計概算料金（USD/JPY）
            - さらにファイル別のサマリー表も `st.dataframe` で表示します。

            ---

            ## 5. 話者分離タブへの引き継ぎ

            連結テキストは：

            - `st.session_state["transcribed_text"]`（連結版）
            - `st.session_state["transcribed_texts"]`（ファイル別リスト）

            として保存されます。

            画面下部では：

            - 直近の連結テキストの **先頭部分（抜粋）** を確認できる expander
            - 「② 話者分離タブへ引き継ぐ」ボタン  
              → 押すと `st.session_state["minutes_source_text"]` に連結テキストをセットし、
                「② 話者分離（Markdown）」タブでそのまま利用できるようにします。

            ---

            ## 6. 典型的な使い方

            1. 会議録やインタビューの音声ファイルを 1〜数本アップロードする。
            2. モデル（精度／コスト）を選ぶ。
            3. 言語コードを `ja` にし、必要なら簡単なプロンプトを書く。
            4. 「文字起こしを実行」ボタンを押す。
            5. 各ファイルのテキストとコストを確認する。
            6. 連結テキストを確認し、「② 話者分離タブへ引き継ぐ」ボタンを押す。
            7. 次のタブで、話者分離や議事録作成に進む。

            以上が、「① 文字起こし（連続対応）」ページのロジックと使い方です。
            """
        )

# 話者分離

def render_speaker_prep_expander() -> None:
    """
    「③ 話者分離・整形」ページのロジックと使い方を expander で描画します。
    pages/xx_話者分離.py などから呼び出して使います。
    """
    with st.expander("ℹ️ ③ 話者分離・整形（議事録前処理）のしくみと使い方（クリックで展開）", expanded=False):
        st.markdown(
            """
            ## 1. このページの役割

            - ① 文字起こしページなどで得られた **生の文字起こしテキスト** を、
              LLM を使って **話者ごとに分離・整形する前処理ページ** です。
            - 入力テキストから、話者（S1 / S2 / …）を推定し、
              発話ごとに改行・整形した形にまとめることを想定しています。
            - 整形後の結果は、そのまま **② 議事録作成ページ** に渡して二次加工できます。

            ---

            ## 2. 全体の処理の流れ

            1. ①ページから `st.session_state["minutes_source_text"]` に入っている文字起こしを、
               初回のみ自動でこのページに取り込みます。
            2. 必要に応じて、
               - プロンプト（必須部分・プリセット・追加指示）
               - モデル / temperature / max_completion_tokens
               を設定します。
            3. 右側に、整形対象の **文字起こしテキスト** を貼り付けるか、
               `.txt` ファイルをドロップします。
            4. 「話者分離して整形」ボタンを押すと、LLM に一回だけリクエストを送り、
               整形結果を受け取ります（**リトライはしない一発実行**）。
            5. 整形されたテキストを画面に表示し、
               - `.txt` ダウンロード
               - クリップボードコピー
               - 料金見積（USD/JPY）
               - トークン情報
               を確認できます。
            6. 必要に応じて、「➕ この結果を『② 議事録作成』へ渡す」ボタンで
               ②ページに引き継ぎます。

            ---

            ## 3. プロンプト周りの構成（lib.prompts レジストリ）

            - `SPEAKER_PREP` グループを `get_group()` で取得し、
              その内容を元にプロンプト UI を組み立てています。
            - プロンプトは次の 3パートを **build_prompt() で連結** して 1 本の指示文にします。

            1. **必ず入る部分（mandatory）**
               - 常にプロンプトの先頭に入る「ベース指示」。
               - 「S1/S2 のような話者ラベルを付ける」「一人称の揺れを整理する」などの
                 方針を書く場所です。
            2. **プリセット本文（preset）**
               - `lib.prompts` に定義してあるプリセット群から選択し、
                 その本文を編集可能な形で表示します。
               - 例：「Zoom 会議の話者分離」「インタビュー用」といった用途別プリセット。
            3. **追加指示（extra）**
               - ケースごとの差分だけを短く追記する場所です。

            > これら 3つと、右側の **入力テキスト（文字起こし本文）** をまとめて
            > LLM に渡すことで、一括の話者分離・整形を行います。

            ---

            ## 4. モデル設定とトークン設定

            ### 🔹 モデル選択

            - 選択肢：
              - `gpt-5`
              - `gpt-5-mini`
              - `gpt-5-nano`
              - `gpt-4.1-mini`
              - `gpt-4.1`
            - いずれも **modern chat API** を想定しています。

            ### 🔹 temperature の扱い

            - `supports_temperature(model)` で  
              「GPT-5 系は temperature 固定」というルールを実装しています。
            - GPT-5 系 (`gpt-5*`) のとき：
              - UI ではスライダーを **無効化**
              - API にも `temperature` を送信しません（=1固定）。
            - GPT-4.1 系のとき：
              - 0.0〜2.0 の範囲でスライダーが有効。
              - ただし **1.0 と異なるときだけ** `chat_kwargs["temperature"]` を付与します。

            ### 🔹 max_completion_tokens（最大出力トークン）

            - modern API の `max_completion_tokens` としてそのまま渡します。
            - 初期値は大きめ（例: 100,000）に設定しており、
              2万文字級の整形でも一度で出し切れることを想定しています。
            - リトライなしのため、
              **最初から余裕を持った値** を指定する前提の設計です。

            ---

            ## 5. 入力テキストの扱い

            右側ペインでは、以下の優先順位で入力テキストを用意します。

            1. `prep_source_text`（本ページで編集中の最新版）
            2. `minutes_source_text`（①や他ページから渡ってきた内容）
            3. それ以外は空

            さらに：

            - 「↩ 文字起こしから再読み込み」ボタン  
              → `minutes_source_text` に現在入っているテキストを
                再度 `prep_source_text` にコピーします。
            - `.txt` ファイルをドロップした場合：
              - UTF-8 でデコードを試み、
              - ダメなら CP932、
              - それもダメなら `errors="ignore"` で読み込み、
              - 読み込んだ内容を `prep_source_text` に格納します。

            ---

            ## 6. 実行ロジック（run_btn）

            「話者分離して整形」ボタンを押すと：

            1. 直近の `prep_source_text`（もしくは `minutes_source_text`）を取得。
            2. 空なら警告を出して終了。
            3. `build_prompt()` で最終プロンプトを組み立て。
            4. `call_once()` を通じて `client.chat.completions.create()` を 1回だけ実行。
               - 引数：
                 - `model`
                 - `messages=[{"role": "user", "content": prompt_text}]`
                 - `max_completion_tokens`
                 - （必要に応じて）`temperature`
            5. `resp.choices[0].message.content`（または `.text`）から出力テキストを取得。
            6. 出力が空でなければ：
               - 「整形結果」として `st.markdown()` で表示。
               - `.txt` ダウンロードボタン
               - クリップボードコピー用ボタン（Clipboard API）を表示。
            7. 出力が空の場合：
               - 「モデルから空の応答」として警告。
               - `resp.model_dump()` を `st.json` で丸ごと表示してデバッグできるようにします。

            ---

            ## 7. トークン・料金の計測

            - `extract_tokens_from_response(resp)`  
              → modern 用の usage から
              **input / output / total トークン数** を取り出します。
            - `estimate_chat_cost_usd(model, input_tok, output_tok)` で  
              model ごとの単価（`config.MODEL_PRICES_USD`）に基づき **概算 USD** を計算します。
            - さらに `USD/JPY` で **概算 JPY** に変換し、
              小さな表（処理時間・トークン数・概算料金）として表示します。
            - 「🔍 トークン算出の内訳」expander では、
              `debug_usage_snapshot(resp.usage)` を出して usage の中身を確認できます。

            ---

            ## 8. ②議事録作成タブへの引き渡し

            - 整形結果は
              - `st.session_state["prep_last_output"]`  
              - `st.session_state["minutes_source_text"]`
              に保存されます。
            - 「➕ この結果を『② 議事録作成』へ渡す」ボタンを押すと：
              - `prep_last_output`（無ければ `minutes_source_text`）を
                再度 `minutes_source_text` にセットし直し、
              - 「② 議事録作成」ページでそのまま利用できる状態にします。

            ---

            ## 9. 長文（2万文字前後）を扱うときの注意

            - 日本語 2万文字は概ね **1万〜1.5万トークン** になることがあります。
            - **gpt-4.1 / gpt-5 系（128k コンテキスト）** の使用を推奨します。
            - `max_completion_tokens` は 8,000〜12,000 程度を目安に、
              「一度で出し切れる値」を指定してください（本版はリトライなし）。
            - 料金テーブルは `config.MODEL_PRICES_USD` を
              運用中の価格に合わせて随時更新してください。

            以上が、「③ 話者分離・整形（議事録の前処理）」ページのロジックと使い方です。
            """
        )

# 議事録作成

def render_minutes_maker_expander() -> None:
    """
    「④ 議事録作成」ページのロジックと使い方を expander で描画します。
    pages/04_議事録作成.py などから呼び出して使います。
    """
    with st.expander("ℹ️ ④ 議事録作成（整形済みテキスト → 正式議事録）のしくみと使い方", expanded=False):
        st.markdown(
            """
            ## 1. このページの役割

            - ③ページ（話者分離・整形）などで得られた  
              **整形済みテキスト（S1/S2形式など）** を入力として、
              **正式な議事録（要約・構成付き）を生成するページ**です。
            - LLM へのプロンプトを
              - 「議事録の種類（逐語録 / 簡易 / 詳細など）」  
              - 「見た目のスタイル（ベーシック / 横線装飾 / Word見出し向け）」  
              の 2軸で切り替えられるようにしてあります。
            - 生成結果は Markdown 表示され、`.txt` / `.docx` でダウンロード可能です。

            ---

            ## 2. 全体の処理の流れ

            1. 左カラムで **議事録の種類** と **見た目スタイル** を選びます。
            2. 必須パート・追記プリセット・追加指示を用いて  
               「LLM に渡す内容側のプロンプト」を整えます。
            3. 右カラムに ③ページの整形結果（.txt / .docx）をアップロードするか、直接貼り付けます。
            4. サイドバーで **モデル / temperature / max_completion_tokens / 為替レート** を設定します。
            5. 「📝 議事録を生成」ボタンを押すと、modern Chat API を 1回だけ呼んで議事録を生成します。
            6. 生成結果を画面に表示し、テキスト保存／Word 保存、料金・トークン情報などを確認できます。

            ---

            ## 3. プロンプト構造（内容 × 見た目の二段構成）

            このページのプロンプトは、次のような構造になっています。

            ### 3-1. 内容系（MINUTES_MAKER グループ）

            - `MINUTES_MANDATORY_MODES` で  
              「逐語録 / 逐語録のまとめ / 簡易議事録 / 詳細議事録」などの  
              **議事録の種類ごとの必須パート**を定義しています。
            - ラジオボタン「議事録の種類」でモードを選ぶと、
              対応する必須パートが `minutes_mandatory` に自動反映されます。
            - さらに `lib.prompts` の `MINUTES_MAKER` グループから
              - 追記プリセット（内容）
              - その本文（編集可）
              を取得して、**内容面の補足指示**を組み立てます。

            ### 3-2. 見た目スタイル（MINUTES_STYLE グループ）

            - `MINUTES_STYLE` グループには、
              - ベーシックな箇条書き
              - 横線やセクション罫線を多用するスタイル
              - Word 見出しとの相性を重視したスタイル
              など、**見た目（レイアウト）に関する指示**をまとめています。
            - ラジオボタン「見た目のスタイル」でラベルを選ぶと、
              その本文を `style_body = style_group.body_for_label(...)` で取得します。

            ### 3-3. 内容プリセット + 見た目スタイルの合体

            - まず「内容プリセット」（`minutes_preset_text`）をベースにし、
            - そこに

              ```text
              【見た目のスタイル指示】
              （MINUTES_STYLE 側の本文）
              ```

              を後ろに付けたものを `merged_preset` として使います。

            ### 3-4. 最終プロンプトの組み立て

            - `build_prompt()` に渡す 4つの要素は：

              1. `minutes_mandatory`（議事録の種類に応じた必須パート）
              2. `merged_preset`（内容プリセット + 見た目スタイル指示）
              3. `minutes_extra_text`（任意の追加指示）
              4. `src`（整形済みテキスト本体）

            - これらを 1本の長いプロンプトに連結して、LLM に渡します。

            ---

            ## 4. 入力テキスト（右カラム）の扱い

            - ③ページの出力を
              - `.txt` または `.docx` ファイルとしてアップロード
              - あるいはテキストエリアへコピペ
              する想定です。

            ### 4-1. .docx アップロード

            - `python-docx`（`docx` モジュール）が利用可能な場合：
              - ファイルを読み込み、すべての段落を結合して 1つのテキストにします。
            - `python-docx` が無い場合：
              - エラーを表示し、インストール (`pip install python-docx`) を促します。

            ### 4-2. .txt アップロード

            - UTF-8 → CP932 → その他（`errors="ignore"`）の順でデコードを試み、
              読み込んだテキストを `minutes_source_text` に格納します。

            ### 4-3. テキストエリア

            - `minutes_source_text` の中身を初期値として表示し、
              直接編集も可能です。
            - 空のまま「議事録を生成」を押すと「整形済みテキストを入力してください」と警告します。

            ---

            ## 5. モデル設定と温度・トークン上限

            サイドバーで次を指定します。

            - モデル：
              - `gpt-5`, `gpt-5-mini`, `gpt-5-nano`, `gpt-4.1-mini`, `gpt-4.1`
            - 温度（0〜2）：
              - GPT-5 系は `supports_temperature()` により **temperature 固定** とみなし、
                スライダーを無効化 & API に temperature を送信しません。
              - GPT-4.1 系は、1.0と異なる場合のみ `chat_kwargs["temperature"]` に設定します。
            - `max_completion_tokens`：
              - modern の `max_completion_tokens` としてそのまま渡されます。
              - 長めの議事録を一度に生成したい場合は 8,000〜12,000 程度を推奨。

            ---

            ## 6. モデル呼び出し（リトライなし一発実行）

            「📝 議事録を生成」ボタンを押すと：

            1. 上述のプロンプト（combined）を作成。
            2. `call_once()` を通じて `client.chat.completions.create()` を **1回だけ**実行。
               - 引数：
                 - `model`
                 - `messages=[{"role": "user", "content": combined}]`
                 - `max_completion_tokens`
                 - （必要に応じて）`temperature`
            3. `resp.choices[0].message.content`（または `.text`）から議事録本文を取得。
            4. 結果が空でなければ `minutes_final_output` として `session_state` に保存し、
               Markdown で表示します。
            5. `finish_reason == "length"` の場合は、
               「出力上限で切れている可能性あり」として info を表示します。
            6. 結果が空の場合は、レスポンス全体 (`resp.model_dump()`) を表示してデバッグできます。

            ---

            ## 7. トークン・料金の概要

            - `extract_tokens_from_response(resp)` で
              **入力トークン / 出力トークン / 合計トークン** を取得します。
            - `estimate_chat_cost_usd(model, input_tok, output_tok)` で USD の概算コストを計算し、
              サイドバーの `USD/JPY` レートを掛けて **JPY の概算** を出します。
            - これらを小さな表として表示し、
              実行ごとのコストを把握しやすくしています。
            - さらに「🔍 トークン算出の内訳」expander では、
              `debug_usage_snapshot(resp.usage)` により modern usage の中身を確認できます。

            ---

            ## 8. 生成結果の保存（.txt / .docx）

            ### 8-1. テキスト保存（.txt）

            - `minutes_final_output` を UTF-8 でエンコードし、
              「💾 テキストで保存 (.txt)」ボタンからダウンロードできます。

            ### 8-2. Word 保存（.docx）

            - `python-docx` が利用可能な場合：
              - Markdown 的な構造を簡易に解釈して Word スタイルに変換します。
              - 主なルール：
                - 空行 → 空段落
                - `---` / `―――` / `ーーー` → 段落下罫線（pBdr）
                - `# 見出し` → Heading 1
                - `## 見出し` → Heading 2
                - `- 箇条書き` → List Bullet スタイル
                - その他の行 → Normal スタイル（行間 1.2、後ろに少しスペース）
              - フォントはデフォルトで「游ゴシック」、サイズ 11pt（通常）、14pt（見出し1）、12pt（見出し2）を指定。
              - ファイル名は
                - 議事録の種類（mode_label）
                - 現在日時（`YYYYMMDD_HHMM`）
                を含めた `"minutes_{safe_label}_{timestamp}.docx"` で出力します。

            ---

            ## 9. 典型的な運用フロー

            1. ① 文字起こし（連続対応）で音声 → テキスト。
            2. ③ 話者分離・整形で、S1/S2形式などの「読みやすい逐語録」に整形。
            3. この④ページに結果を渡し、
               - 「議事録の種類」を選ぶ（例：簡易議事録）
               - 「見た目のスタイル」を選ぶ（例：Word見出し向け）
            4. 必要なら追加指示（議題の順番、決定事項の書き方など）を記入。
            5. 「議事録を生成」を実行。
            6. 画面で確認し、`.txt` や `.docx` を保存して配布。

            以上が、「④ 議事録作成（整形済みテキスト → 議事録）」ページのロジックと使い方です。
            """
        )



# 既存：
# def render_minutes_maker_expander() -> None:
#     ...
def render_minutes_prompt_spec_expander() -> None:
    """
    Minutes Maker で GPT に送られるプロンプト原文を表示する expander。
    pages/07_議事録作成（新）.py などから呼び出して使います。
    """
    import streamlit as st

    with st.expander("🧾 GPT に送るプロンプト（Minutes Maker の原文テンプレート）", expanded=False):
        st.markdown(
            """
## Minutes Maker に渡されるプロンプト構造（GPT への最終プロンプト）

このページでは，Minutes Maker から GPT に送られるプロンプト原文を，構成要素ごとにそのままの形で示します。  
実際の呼び出しでは，下記 1〜4 をこの順番で連結したものが 1 本のプロンプトとして送信されます。

1. Minutes Maker 全体共通 mandatory（`MINUTES_GLOBAL_MANDATORY`）
2. モード別 mandatory（逐語録／簡易議事録／詳細議事録のいずれか 1 本）
3. 追記プリセット＋見た目スタイル（`merged_preset`）
4. 追加指示（任意）と入力テキスト（整形済みテキスト）

---

## 1. Minutes Maker 全体共通 mandatory

`MINUTES_GLOBAL_MANDATORY` の原文は次の通りです。

---

### 1-1. MINUTES_GLOBAL_MANDATORY 本文

あなたは日本語の会議議事録（逐語録・簡易議事録・詳細議事録）を作成する専門家です。  
以下の入力テキスト（整形済みテキスト：話者ごとに分離されたテキスト）をもとに，  
指定されたモードに応じた形式の議事録を出力してください。

【共通方針】

- 事実関係を改変してはいけません。推測や補完を行う場合は，「〜と考えられる」「〜と思われる」など不確実性が分かる表現で示してください。
- 日付・時刻・数値は，原則として半角で統一してください（例: 2025-12-08, 10:30, 3 件）。
- 固有名詞（人名・地名・組織名・資料名など）は，入力テキスト中の表記をできるだけ尊重してください。
- 同じ内容を繰り返し説明しないようにし，読み手が「何が議論され，何が決まり，次に何をするのか」を素早く把握できる構成を心がけてください。

【書式・見た目に関する共通ルール】

- 見出しには Markdown の見出し記法（`#`, `##`, `###`）を使用してください（行頭に全角スペースを入れない）。
- 箇条書きは「`- `」（半角ハイフン＋半角スペース）を用いてください。Tab は使わず，必要に応じて半角スペースでインデントしてください。
- 行頭に「*」「●」「■」などの記号を用いた独自の箇条書きは使わないでください。
- 不要な空行は避け，見出しやセクションの区切りの前後など，意味のある箇所にだけ空行を入れてください。

【表の出力に関する共通ルール（重要）】

- 「変更指示一覧」「TODO 一覧」「決定事項一覧」など，表形式の出力が必要な場合は，必ず Markdown の表記法を用いて出力してください。
- 表の構造は次の形式に従ってください（例）：

  | 列1 | 列2 | 列3 |
  | --- | --- | --- |
  | 値1 | 値2 | 値3 |

  ※この例は構造を示すだけであり，実際の列名・列数は指示に応じて変更して構いません。

- 表に関する厳守事項:
  - 各行の先頭と末尾，および列の区切りには半角の縦棒 `|` を使ってください。全角の「｜」は絶対に使わないでください。
  - 行頭に余分な空白（特に全角スペース）を入れないでください。
  - コードブロック（``` で囲む形式）は使わないでください。表そのものだけを出力してください。
  - セル内で改行しないでください。複数文が必要な場合でも 1 セル内に 1 つの段落としてまとめてください。
  - セル内に `|` を含める必要がある場合は，必ず `\\|` とエスケープしてください。
  - 空欄セルが必要なときは完全な空文字ではなく，半角スペース 1 つを入れておいてください。

- 「表形式だけを出力してください」「表のみを返してください」などと明示された場合は，上記の Markdown 表以外のテキスト（説明文・見出し・前置きなど）を書いてはいけません。  
  そうでない場合は，議事録本文のなかに必要に応じて表を挿入して構いません。

これらの共通ルールは，逐語録・簡易議事録・詳細議事録のいずれのモードでも必ず守ってください。

---

## 2. モード別 mandatory（逐語録／簡易議事録／詳細議事録のいずれか 1 本）

画面の「議事録の種類」で選んだモードに応じて，下記のうちどれか 1 本が  
上記の Minutes Maker 全体共通 mandatory の **後ろに連結** されます。

---

### 2-1. 逐語録モード（`"逐語録"`）

あなたは日本語の会議逐語録を整える専門家です。  
以下の「整形済みテキスト」（話者ごとに分離されたテキスト）をもとに，  
元の発話内容をできるだけ忠実に残した「逐語録」を作成してください。

【要件】

- 発言の順序は変えないこと。
- 語句の変更は行わないこと。

【出力フォーマット（構成例）】

- 「会議概要」という見出し
  - 会議名（分かる範囲で）
  - 主なテーマ
  - 日時・場所（分かる範囲で）
  - 参加者（役職や氏名が分かる範囲で）

- 「逐語録」という見出し
  - 発言ごとのテキストを，発言番号付きで列挙する（例：「（0001）発言内容…」）。
  - 発言ごとに空白行を入れて，読みやすくしてください。

---

### 2-2. 簡易議事録モード（`"簡易議事録"`）

あなたは日本語の会議議事録を作成する専門家です。  
以下の「整形済みテキスト」（話者ごとに分離されたテキスト）をもとに，  
会議の要点を押さえた「簡易議事録」を作成してください。

【基本方針】

- 発言内容をそのまま書き写すのではなく，論点・意見・確認事項・決定事項を整理してまとめてください。
- 脱線した雑談や細かな言い回しは省略して構いません。
- あとから参加者が読み返したときに「どのような議論があり，何が決まったか」が把握できるレベルを目指します。
- 全体として A4 1〜2 枚程度のボリューム感に収まる密度で要約してください。

【出力フォーマット（構成例）】

- 「会議概要」
  - 会議名（分かる範囲で）
  - 主なテーマ
  - 日時・場所（分かる範囲で）
  - 参加者（役職や氏名が分かる範囲で）

- 「議論の概要」
  - 議論された主なトピックを箇条書きで整理（1 トピックあたり 1〜3 行）

- 「決定事項」
  - 箇条書きで簡潔に記述（1 行で要約）
  - 必要に応じて背景を 1 文だけ補足してもよい

- 「TODO」
  - 例）[担当: 氏名または部署, 期限: 分かる範囲で] 作業内容
  - 期限や担当が不明な場合は「担当・期限: 未確定」と明記

- 「メモ・補足」（任意）
  - 今後の検討事項や，論点として残しておくべき内容があれば簡潔に記載

【制約】

- 事実の改変は禁止（推測が入るときは「〜と考えられる」「〜と思われる」といった表現を用いる）。
- 日付・時刻・数量は半角で統一してください。
- 固有名詞はできるだけ元の表記を維持してください。

---

### 2-3. 詳細議事録モード（`"詳細議事録"`）

あなたは会議の議事録作成の専門家です。  
与えられた整形済みテキストから，重要事項・決定事項・TODO（担当者・期限）・論点・論拠・未解決事項を正確に抽出し，  
わかりやすく構造化した日本語の詳細議事録を作成してください。

【出力フォーマット（構成と順序）】

- 「サマリー」
  - 全体の要約を 3〜5 行程度で記載する。

- 「決定事項」
  - 箇条書き（番号付き）で列挙する。
  - 各項目に背景や根拠を 1 文で添付する。

- 「TODO（担当・期限つき）」
  - 例）[担当: 氏名, 期限: YYYY-MM-DD] 具体的な作業内容

- 「重要トピック（最大 5 つ）」
  - 各トピックについて，主な論点と結論を短く整理する。

- 「補足・論拠」
  - 参照すべき資料・データがあれば列挙する。

- 「未解決事項・次回アジェンダ」
  - 今後検討が必要な事項や，次回会議で扱うべきトピックを記載する。

【制約】

- 事実の改変は禁止（聞き違いの推測は「不確実」であることを明記）。
- 日付・数量は半角，固有名詞は元の表記を維持する。
- 箇条書きは簡潔にし，1 行 80 字程度を目安に適宜改行する。
- 重要な発言については「誰が・何を主張したか」が分かるように要約する。

---

## 3. 追記プリセット＋見た目スタイル（`merged_preset`）

ここでは，内容側の追記プリセット（任意）と，「見た目 3：Word 見出しスタイル向け」のスタイル指定をまとめて示します。  
実際の呼び出しでは，下記のいずれか 1 つの追記プリセット本文（または空）とスタイル指定が連結され，  
`merged_preset` として `build_prompt` の第 2 引数に渡されます。

---

### 3-1. 追記プリセット（内容側）

- (a) 追記なし（`"none"`）  
  - 追記本文は空文字列。

- (b) サマリを箇条書きで厳密化（`"with_summary_points"`）  

  サマリーは必ず 5 行以内とし，文頭に「・」を付けた箇条書き形式で，  
  会議の目的・結論・重要な決定事項が一目で分かるように簡潔に要約してください。

- (c) リスク／懸念の抽出を追加（`"add_risks"`）  

  「リスク・懸念」という見出しを設け，次のように出力してください。

  - コスト，スケジュール，品質，セキュリティ，法務の観点で潜在的リスクを抽出する。
  - 各リスクについて「発生確率（低／中／高）」と「影響度（低／中／高）」をタグとして付与する。

- (d) 経営向けブリーフ（A4 半頁）（`"exec_brief"`）  

  経営層向けに A4 半頁相当のブリーフも併記してください。  
  見出しは「エグゼクティブ・ブリーフ」とし，  
  目的／現状／意思決定事項／次アクションを 3〜6 行で簡潔にまとめてください。

- (e) 元テキストのタイムコード参照付き（`"inline_timecodes"`）  

  元テキストに `[hh:mm:ss]` 等のタイムコードが含まれている場合，  
  可能な範囲で関連する項目の末尾に括弧付きで付与してください（例：「（参照: 00:12:34）」）。

---

### 3-2. 見た目スタイル（Minutes Style）

Minutes Style には，現在「見た目 3：Word 見出しスタイル向け」だけが定義されています。  
`style_word_headings` の本文は次の通りです。

【見た目スタイル：Word 見出しスタイル向け】

- 見出しは Markdown の見出し記法（`#`, `##`, `###`）を使用してください。
- 箇条書きは「`- `」（半角ハイフン＋半角スペース）で統一してください。
- 第 1 階層の箇条書きは，行頭に何も置かず「`- `」で始めてください。
- 第 2 階層の箇条書きは，行頭に半角スペース 2 個を入れてから「`- `」で始めてください。
- 第 3 階層の箇条書きは，行頭に半角スペース 4 個を入れてから「`- `」で始めてください。
- Tab キーは使わず，かならず半角スペースでインデントを表現してください。
- 見出し行および箇条書き行の先頭に不要な全角スペースは入れないでください。
- 行頭に「*」「●」「■」などの記号を置かないでください（箇条書き以外）。
- 空行は必要最小限とし，見出しの前後とセクションの区切りにだけ入れてください。
- 段落は左揃えを基本とし，行頭インデントは付けないでください。
- （重要）第 2 階層まで入れ子になっている箇条書きは読みやすいので，積極的に使用してください。

---

## 4. 追加指示と入力テキスト

最後に，画面の「追加指示（任意）」で入力されたテキストと，  
右カラムに貼り付けた「整形済みテキスト」が，次の形式で末尾に追加されます。

- 追加指示（`minutes_extra_text` が空でない場合）

  【追加指示】  
  ＜画面の「追加指示（任意）」に入力した内容＞

- 入力テキスト（整形済みテキスト）

  【入力テキスト】  
  ＜③ ページから引き継いだ整形済みテキスト＞

---

## 5. GPT に送られる最終プロンプトの全体像（概念テンプレート）

以上を踏まえると，GPT に送られる 1 本のプロンプトは概念的には次のようになります。

- [1] Minutes Maker 全体共通 mandatory  
  （`MINUTES_GLOBAL_MANDATORY`）

- [2] モード別 mandatory のいずれか 1 本  
  （逐語録／簡易議事録／詳細議事録）

- [3] 追記プリセット＋見た目スタイル（`merged_preset`）  
  （選択した追記プリセット本文 ＋ 「【見た目のスタイル指示】」＋ Word 見出しスタイル）

- [4] 追加指示（任意）  
  「【追加指示】」＋ ユーザーが入力した補足プロンプト

- [5] 入力テキスト  
  「【入力テキスト】」＋ 整形済みテキスト（話者分離済み）

この順番で連結された 1 本の文字列が，`build_prompt()` を通じて GPT に送信されています。
            """
        )
